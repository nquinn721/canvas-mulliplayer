import React, { useEffect, useRef, useState } from 'react';
import { TreeSpriteManager } from '../utils/TreeSpriteManager';

interface SpriteDemoProps {
  visible?: boolean;
  onClose?: () => void;
}

export const SpriteDemo: React.FC<SpriteDemoProps> = ({ visible = false, onClose }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [treeManager] = useState(new TreeSpriteManager());
  const [isLoaded, setIsLoaded] = useState(false);
  const [treeCount, setTreeCount] = useState(0);
  const [frameSize, setFrameSize] = useState({ width: 32, height: 32 });
  const [selectedFrame, setSelectedFrame] = useState(0);

  useEffect(() => {
    if (visible) {
      loadSprites();
    }
  }, [visible]);

  const loadSprites = async () => {
    try {
      // Use pixel detection to automatically find sprites
      await treeManager.loadTrees({
        transparentThreshold: 10,
        minSpriteSize: 4,
        padding: 2,
        mergeTolerance: 3
      });
      setIsLoaded(true);
      setTreeCount(treeManager.getTreeCount());
      
      const dimensions = treeManager.getTreeDimensions();
      if (dimensions) {
        setFrameSize(dimensions);
      }
      
      drawDemo();
    } catch (error) {
      console.error('Failed to load sprites:', error);
    }
  };

  const drawDemo = () => {
    const canvas = canvasRef.current;
    if (!canvas || !isLoaded) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background
    ctx.fillStyle = '#2d3748';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw title
    ctx.fillStyle = 'white';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Pixel-Detected Tree Sprites', 10, 30);
    ctx.font = '12px Arial';
    ctx.fillText('Sprites automatically detected by analyzing colored pixels', 10, 50);

    // Draw grid of all tree sprites (offset down to make room for title)
    const treeStartY = 70;
    const padding = 10;
    const scale = 2; // Scale up the sprites for better visibility
    const cols = Math.floor((canvas.width - padding) / (60 + padding));
    
    for (let i = 0; i < treeCount; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = padding + col * (60 + padding);
      const y = treeStartY + padding + row * (60 + padding);
      
      // Get sprite info for proper sizing
      const sprite = treeManager.getTreeSprite(i);
      if (!sprite) continue;
      
      const scaledWidth = sprite.width * scale;
      const scaledHeight = sprite.height * scale;
      
      // Highlight selected frame
      if (i === selectedFrame) {
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 3;
        ctx.strokeRect(x - 2, y - 2, scaledWidth + 4, scaledHeight + 4);
      }
      
      // Draw tree sprite
      treeManager.drawTree(ctx, i, x, y, scaledWidth, scaledHeight);
      
      // Draw frame number
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(i.toString(), x + scaledWidth / 2, y - 5);
      
      // Draw sprite dimensions
      ctx.font = '8px Arial';
      ctx.fillText(`${sprite.width}x${sprite.height}`, x + scaledWidth / 2, y + scaledHeight + 12);
    }
    
    // Draw info
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Sprites detected: ${treeCount}`, 10, canvas.height - 60);
    
    const selectedSprite = treeManager.getTreeSprite(selectedFrame);
    if (selectedSprite) {
      ctx.fillText(`Selected: Sprite ${selectedFrame} (${selectedSprite.width}x${selectedSprite.height}px)`, 10, canvas.height - 40);
    }
    
    const options = treeManager.getDetectionOptions();
    ctx.font = '12px Arial';
    ctx.fillText(`Detection: threshold=${options.transparentThreshold}, minSize=${options.minSpriteSize}, padding=${options.padding}`, 10, canvas.height - 20);
  };

  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas || !isLoaded) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    // Calculate which sprite was clicked
    const padding = 10;
    const scale = 2;
    const treeStartY = 70;
    const cols = Math.floor((canvas.width - padding) / (60 + padding));
    
    // Check each sprite bounds individually since they have different sizes
    for (let i = 0; i < treeCount; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = padding + col * (60 + padding);
      const y = treeStartY + padding + row * (60 + padding);
      
      const sprite = treeManager.getTreeSprite(i);
      if (!sprite) continue;
      
      const scaledWidth = sprite.width * scale;
      const scaledHeight = sprite.height * scale;
      
      // Check if click is within this sprite's bounds
      if (clickX >= x && clickX <= x + scaledWidth && 
          clickY >= y && clickY <= y + scaledHeight) {
        setSelectedFrame(i);
        return;
      }
    }
  };

  const loadCustomSize = async () => {
    const minSize = parseInt(prompt('Enter minimum sprite size (pixels):') || '4');
    const threshold = parseInt(prompt('Enter transparency threshold (0-255):') || '10');
    const padding = parseInt(prompt('Enter padding around sprites:') || '2');
    const mergeTolerance = parseInt(prompt('Enter merge tolerance (pixels):') || '3');
    
    if (minSize > 0 && threshold >= 0 && threshold <= 255) {
      await treeManager.loadTrees({
        transparentThreshold: threshold,
        minSpriteSize: minSize,
        padding: padding,
        mergeTolerance: mergeTolerance
      });
      setTreeCount(treeManager.getTreeCount());
      
      const dimensions = treeManager.getTreeDimensions();
      if (dimensions) {
        setFrameSize(dimensions);
      }
      
      drawDemo();
    }
  };

  const exportFrames = () => {
    const frames = treeManager.exportTreeFrames();
    frames.forEach((canvas, index) => {
      const link = document.createElement('a');
      link.download = `tree_frame_${index}.png`;
      link.href = canvas.toDataURL();
      link.click();
    });
  };

  useEffect(() => {
    if (isLoaded) {
      drawDemo();
    }
  }, [isLoaded, selectedFrame, treeCount, frameSize]);

  if (!visible) return null;

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      backgroundColor: 'rgba(0, 0, 0, 0.8)',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000
    }}>
      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '8px',
        maxWidth: '90%',
        maxHeight: '90%',
        overflow: 'auto'
      }}>
        <div style={{ marginBottom: '10px', display: 'flex', gap: '10px', alignItems: 'center' }}>
          <h2 style={{ color: 'white', margin: 0 }}>Pixel Detection Demo - Trees</h2>
          <button onClick={loadCustomSize} style={{ padding: '5px 10px' }}>
            Detection Settings
          </button>
          <button onClick={exportFrames} style={{ padding: '5px 10px' }}>
            Export Sprites
          </button>
          <button onClick={onClose} style={{ padding: '5px 10px', marginLeft: 'auto' }}>
            Close
          </button>
        </div>
        
        <canvas
          ref={canvasRef}
          width={800}
          height={600}
          style={{ 
            border: '2px solid #333',
            cursor: 'pointer',
            backgroundColor: '#2d3748'
          }}
          onClick={handleCanvasClick}
        />
        
        <div style={{ color: 'white', marginTop: '10px' }}>
          <p>Click on any sprite to select it. Use "Detection Settings" to adjust pixel detection parameters.</p>
          <p>System automatically detects colored pixels and creates bounding rectangles around sprites.</p>
          <p>Total sprites detected: {treeCount}</p>
        </div>
      </div>
    </div>
  );
};
